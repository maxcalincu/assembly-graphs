**The Largest Assembly Number of an Assembly Graph with a Given Number of Vertices**

## library/core

### include/core/basics.h, src/basics
Описаны классы Vertex, Edge, ECyc.
- **Vertex** — класс вершины. Вершины можно лишь сравнивать друг с другом.
- **Edge** — класс ориентированного ребра сборного графа. Ориентированность нужна для того, чтобы множество соседей ребра ``e`` для вершины ``v`` было определено, даже если ``e`` — петля.
- **ECyc** класс циклического порядка вершины, определенный так же, как в научных статьях.

Для **Edge** также определены вспомогательные классы-коллекции **Tier** и **Polarity**.
- **Tier** — принимает значения ``{A, B, C, D, X}`` и нужен для того, чтобы можно было различать кратные ребра сборного графа. Потребность в значении ``X`` возникает по техническим причинам.
- **Polarity** — принимает значения ``{Positive, Negative}``. С помощью него вводится конструкция, позволяющая корректно определить ориентацию для петель. 

По аналогии с положительно и отрицательно заряженными концами молекулы мы фиксируем порядок на концах ребра: один конец положительный, другой — отрицательный. Полярность никак не распростроняется на вершины: ребра одной вершины могут иметь противоположный заряд на концах соответствующих этой вершине. В частности, для петель это неизбежно.

Ориентацию можно определить через заряд конца, в сторону которого ребро направлено. Легко доказать, что такое определение корректно.

### include/core/interfaces
Определены интерфейсы ``ISimpleAssembleGraph`` и ``ITwoWord``. В них описана функциональность, что должна присутствовать в сборных графов: с концевыми вершинами или без них, а также с петлями или без них.

### include/core/sag_with_endpoints.h, src/sag_with_endpoints
Описан класс ``SAGWithEndpoints`` (SAG = simple assembly graph).

- Структура графа задана списком упорядоченных вершин, их порядков и информацией о концевых вершинах.

  ```cpp
    std::map<Vertex, ECyc> cyclic_order;
    Edge StartEdge;
    Edge LastEdge;
    ```
- Переход от вершины к соседней по ребру происходит за $O(\log n)$. Логарифмическая сложность возникает из-за обращения к ``std::map``.
- Вставка и удаление вершины происходит за $O(\log n)$, поскольку состояние меняется только для константного числа вершин, доступ к которым осуществляется за логарифм.
- Вставка графа $\Gamma_1$ в произвольное место графа $\Gamma$ происходит за $O(|\Gamma_1| + log|\Gamma|)$, так как состояние подграфа нужно скопировать в состояние $\Gamma$.
- Итерация по трансверсальному пути занимает $O(n)$. Быстрый случайный доступ к ребрам в порядке трансверсального пути недостижим из-за постоянных вставок и удалений вершин. К счастью, такой доступ легко исключить благодаря выбору подходящих алгоритмов.
- Будем поддерживать следующий инвариант. Зафиксируем трансверсальный путь $\{v_0, v_1, ..., v_{2|\Gamma|}\}$ такой, что ориентированное ребро $e_0 = (v_0, v_{1})$ имеет положительную полярность (т. е. ``e.GetOrientation() == Polarity::Positive``). Тогда все ориентированные ребра вида $e_i = (v_i, v_{i + 1})$ имеют положительную полярность.
  ```cpp
  auto check_polarity_invariant = [](const SAGWithEndpoints& graph) {
      for (auto edge = graph.GetKthEdge(0); edge != graph.GetLastEdge(); edge = graph.TransversalAdvance(edge)) {        
          REQUIRE(edge.GetOrientation() == graph.GetLastEdge().GetOrientation());
      }
  };
  ```
