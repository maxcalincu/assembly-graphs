## src/basics
Описаны классы Vertex, Edge, ECyc.
- **Vertex** — класс вершины. Вершины можно лишь сравнивать друг с другом.
- **Edge** — класс ориентированного ребра сборного графа. Ориентированность нужна для того, чтобы множество соседей ребра ``e`` для вершины ``v`` было определено, даже если ``e`` — петля.
- **ECyc** класс циклического порядка вершины, определенный так же, как в научных статьях.

Для **Edge** также определены вспомогательные классы-коллекции **Tier** и **Polarity**.
- **Tier** — принимает значения ``{A, B, C, D, X}`` и нужен для того, чтобы можно было различать кратные ребра сборного графа (различным ребрам ``(a, b)`` присваиваются различные ``Tier``). Потребность в значении ``X`` возникает по техническим причинам.
- **Polarity** — принимает значения ``{Positive, Negative}``. С помощью него вводится конструкция, позволяющая корректно определить ориентацию для петель. 

По аналогии с положительно и отрицательно заряженными концами молекулы мы фиксируем порядок на концах ребра: один конец положительный, другой — отрицательный. Полярность никак не распростроняется на вершины: ребра одной вершины могут иметь противоположный заряд на концах соответствующих этой вершине. В частности, для петель это неизбежно.

Ориентацию можно определить через заряд конца, в сторону которого ребро направлено. Легко доказать, что такое определение корректно.

## src/sag_with_endpoints
Описан класс ``SAGWithEndpoints`` (SAG = simple assembly graph).

- Структура графа задана списком упорядоченных вершин, их порядков и информацией о концевых вершинах.

  ```cpp
    std::map<Vertex, ECyc> cyclic_order;
    Edge StartEdge;
    Edge LastEdge;
    ```
- Переход от вершины к соседней по ребру происходит за $O(\log n)$. Логарифмическая сложность возникает из-за обращения к ``std::map``.
- Вставка и удаление вершины происходит за $O(\log n)$, поскольку состояние меняется только для константного числа вершин, доступ к которым осуществляется за логарифм.
- Вставка графа $\Gamma_1$ в произвольное место графа $\Gamma$ происходит за $O(|\Gamma_1| + log|\Gamma|)$, так как состояние подграфа нужно скопировать в состояние $\Gamma$.
- Итерация по трансверсальному пути занимает $O(n)$. Быстрый случайный доступ к ребрам в порядке трансверсального пути недостижим из-за постоянных вставок и удалений вершин. К счастью, такой доступ легко исключить благодаря выбору подходящих алгоритмов.
- Будем поддерживать следующий инвариант. Зафиксируем трансверсальный путь $\{v_0, v_1, ..., v_{2|\Gamma|}\}$ такой, что ориентированное ребро $e_0 = (v_0, v_{1})$ имеет положительную полярность (т. е. ``e.GetOrientation() == Polarity::Positive``). Тогда все ориентированные ребра вида $e_i = (v_i, v_{i + 1})$ имеют положительную полярность.
  ```cpp
  auto check_polarity_invariant = [](const SAGWithEndpoints& graph) {
      for (auto edge = graph.GetKthEdge(0); edge != graph.GetLastEdge(); edge = graph.TransversalAdvance(edge)) {        
          REQUIRE(edge.GetOrientation() == graph.GetLastEdge().GetOrientation());
      }
  };
  ```

## src/generators
Определен генератор для простых сборных графов ``SAGGenerator<SAGWithEndpoints>``. Любые два, графа сгенерированных этим алгоритмом, не изоморфны.
- Метод ``GetLexicographicallySmallest`` возвращает граф, соответствующий лексикографически минимальному 2-слову. Сложность $O(|\Gamma|)$
- Метод ``Advance`` преобразует граф в следующее по порядку 2-слово. Порядок не совсем лексикографиечский. Амортизированная сложность $O(log|\Gamma|)$ 
- Проитерироваться по всем простым сборным графам размера ``n`` можно так:
  ```cpp
  auto generator = SAGGenerator<SAGWithEndpoints>();
  for (auto graph = generator.GetLexicographicallySmallest(0, n); Advance(graph);) {
      /*...*/
  }
  ```

## src/paths
Определен класс ``SetOfPolygonalPaths<SAGWithEndpoints>``. 
- Класс содержит некоторое подмножество ребер графа. Ребра формируют гамильтоново множество полигональных путей.
- Структура поддерживает вставку и удаление ребра. Cложность вставки $O(log|\Gamma|)$. Сложность удаления $O(|\Gamma|)$.
- Остальные методы ``SetOfPolygonalPaths<SAGWithEndpoints>`` также имеют сложность $O(log|\Gamma|)$.

## src/set_builders

Для ознакомления см. описание `scripts/construct_set`